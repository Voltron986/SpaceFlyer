<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Game Demo with Gun Animation and Enemies</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="debug">
        Position: (0, 0, 0)<br>
        Rotation: 0Â°<br>
        Enemies: 0
    </div>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Maze generation
        const gridSize = 16;
        const cellSize = 4;
        const maze = [];
        for (let x = 0; x < gridSize; x++) {
            maze[x] = [];
            for (let z = 0; z < gridSize; z++) {
                if (x === 0 || x === gridSize - 1 || z === 0 || z === gridSize - 1) {
                    maze[x][z] = 1;
                } else if (x >= 6 && x <= 9 && z >= 6 && z <= 9) {
                    maze[x][z] = 0;
                } else {
                    maze[x][z] = Math.random() < 0.15 ? 1 : 0;
                }
            }
        }

        // Procedural textures
        function createFloorTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            for (let i = 0; i < 256; i += 32) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 256);
                ctx.moveTo(0, i);
                ctx.lineTo(256, i);
                ctx.stroke();
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createWallTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#696969';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.2)`;
                ctx.fillRect(Math.random() * 256, Math.random() * 256, 20, 20);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            return texture;
        }

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(gridSize * cellSize, gridSize * cellSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ map: createFloorTexture() });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set((gridSize * cellSize) / 2 - cellSize / 2, 0, (gridSize * cellSize) / 2 - cellSize / 2);
        scene.add(floor);

        // Walls and collision
        const wallGeometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        const wallMaterial = new THREE.MeshStandardMaterial({ map: createWallTexture() });
        const walls = [];
        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                if (maze[x][z] === 1) {
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(x * cellSize, cellSize / 2, z * cellSize);
                    scene.add(wall);
                    wall.boundingBox = new THREE.Box3().setFromObject(wall);
                    walls.push(wall);
                }
            }
        }

        // Soldier with gun and animations
        let soldier, mixer, idleAction, runAction, activeAction, gun, rightHandBone;
        let isShooting = false;
        let shootTimer = 0;
        const shootDuration = 0.3; // Duration of shooting pose in seconds
        const loader = new THREE.GLTFLoader();
        loader.load('https://threejs.org/examples/models/gltf/Soldier.glb', (gltf) => {
            soldier = gltf.scene;
            soldier.scale.set(2, 2, 2);
            soldier.position.set(7.5 * cellSize, 0, 7.5 * cellSize);
            scene.add(soldier);

            mixer = new THREE.AnimationMixer(soldier);
            idleAction = mixer.clipAction(gltf.animations[0]);
            runAction = mixer.clipAction(gltf.animations[3]);
            idleAction.play();
            activeAction = idleAction;

            // Add gun to soldier's right hand
            const gunGeometry = new THREE.BoxGeometry(0.5, 0.2, 1.5);
            const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            gun = new THREE.Mesh(gunGeometry, gunMaterial);
            soldier.traverse((child) => {
                if (child.isBone && child.name.includes('Hand_R')) {
                    rightHandBone = child;
                    rightHandBone.add(gun);
                    gun.position.set(0, 0, -0.5);
                    gun.rotation.set(0, Math.PI / 2, 0);
                }
            });
        });

        // Camera and controls
        camera.position.set(7.5 * cellSize, 10, 10 * cellSize);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(7.5 * cellSize, 0, 7.5 * cellSize);
        controls.update();

        // Movement and shooting
        const keysPressed = { w: false, a: false, s: false, d: false, space: false };
        const moveSpeed = 0.2;
        const collisionRadius = 1.5;
        const bullets = [];
        const bulletSpeed = 1;
        let lastShotTime = 0;
        const shootCooldown = 0.2;

        document.addEventListener('keydown', (e) => {
            if (e.key in keysPressed) keysPressed[e.key.toLowerCase()] = true;
            if (e.key === ' ' && soldier && !isShooting) {
                shoot();
                isShooting = true;
                shootTimer = shootDuration;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.key in keysPressed) keysPressed[e.key.toLowerCase()] = false;
        });

        function moveSoldier(delta) {
            if (!soldier) return;

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const left = new THREE.Vector3();
            left.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            const moveDirection = new THREE.Vector3();
            if (keysPressed.w) moveDirection.add(forward);
            if (keysPressed.s) moveDirection.sub(forward);
            if (keysPressed.a) moveDirection.add(left);
            if (keysPressed.d) moveDirection.sub(left);

            const isMoving = moveDirection.length() > 0;
            if (isMoving && !isShooting) {
                moveDirection.normalize();
                const newPosition = soldier.position.clone().add(moveDirection.multiplyScalar(moveSpeed));

                let collision = false;
                for (const wall of walls) {
                    const soldierBox = new THREE.Sphere(newPosition, collisionRadius);
                    if (wall.boundingBox.intersectsSphere(soldierBox)) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    soldier.position.copy(newPosition);
                    const angle = Math.atan2(moveDirection.x, moveDirection.z);
                    soldier.rotation.y = angle + Math.PI;
                }

                if (activeAction !== runAction) {
                    activeAction.fadeOut(0.2);
                    runAction.reset().fadeIn(0.2).play();
                    activeAction = runAction;
                }
            } else if (!isShooting && activeAction !== idleAction) {
                activeAction.fadeOut(0.2);
                idleAction.reset().fadeIn(0.2).play();
                activeAction = idleAction;
            }

            // Shooting animation
            if (isShooting && rightHandBone) {
                shootTimer -= delta;
                if (shootTimer > 0) {
                    // Simulate recoil
                    gun.position.z = -0.5 - Math.sin(shootTimer / shootDuration * Math.PI) * 0.1;
                    rightHandBone.rotation.x = -Math.PI / 6; // Raise arm slightly
                } else {
                    isShooting = false;
                    gun.position.z = -0.5;
                    rightHandBone.rotation.x = 0; // Reset arm
                    if (isMoving) {
                        activeAction.fadeOut(0.2);
                        runAction.reset().fadeIn(0.2).play();
                        activeAction = runAction;
                    } else {
                        activeAction.fadeOut(0.2);
                        idleAction.reset().fadeIn(0.2).play();
                        activeAction = idleAction;
                    }
                }
            }

            controls.target.copy(soldier.position);
            controls.update();
        }

        function shoot() {
            const currentTime = clock.getElapsedTime();
            if (currentTime - lastShotTime < shootCooldown) return;
            lastShotTime = currentTime;

            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(soldier.position);
            bullet.position.y = 1;

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            bullet.userData.velocity = forward.clone().multiplyScalar(bulletSpeed);

            scene.add(bullet);
            bullets.push(bullet);
        }

        // Enemies
        const enemies = [];
        const enemyGeometry = new THREE.BoxGeometry(2, 2, 2);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const numEnemies = 5;

        function spawnEnemy() {
            let x, z;
            do {
                x = Math.floor(Math.random() * gridSize);
                z = Math.floor(Math.random() * gridSize);
            } while (maze[x][z] === 1 || (x >= 6 && x <= 9 && z >= 6 && z <= 9));

            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(x * cellSize, 1, z * cellSize);
            enemy.boundingBox = new THREE.Box3().setFromObject(enemy);
            scene.add(enemy);
            enemies.push(enemy);
        }

        for (let i = 0; i < numEnemies; i++) spawnEnemy();

        function moveEnemies(delta) {
            enemies.forEach((enemy, index) => {
                if (!soldier) return;

                const direction = soldier.position.clone().sub(enemy.position);
                const distance = direction.length();
                direction.y = 0;
                direction.normalize();

                if (distance > 5) {
                    const newPosition = enemy.position.clone().add(direction.multiplyScalar(0.1));
                    let collision = false;

                    for (const wall of walls) {
                        const enemyBox = new THREE.Sphere(newPosition, 1);
                        if (wall.boundingBox.intersectsSphere(enemyBox)) {
                            collision = true;
                            break;
                        }
                    }

                    for (let j = 0; j < enemies.length; j++) {
                        if (j !== index) {
                            const otherEnemy = enemies[j];
                            const distToOther = newPosition.distanceTo(otherEnemy.position);
                            if (distToOther < 2) {
                                collision = true;
                                break;
                            }
                        }
                    }

                    if (!collision) {
                        enemy.position.copy(newPosition);
                        enemy.boundingBox.setFromObject(enemy);
                    }
                }

                const angle = Math.atan2(direction.x, direction.z);
                enemy.rotation.y = angle;
            });
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.userData.velocity);

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const bulletBox = new THREE.Sphere(bullet.position, 0.1);
                    if (enemy.boundingBox.intersectsSphere(bulletBox)) {
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        break;
                    }
                }

                if (bullets[i]) {
                    let wallHit = false;
                    for (const wall of walls) {
                        if (wall.boundingBox.containsPoint(bullet.position)) {
                            wallHit = true;
                            break;
                        }
                    }
                    if (wallHit || bullet.position.x < 0 || bullet.position.x > gridSize * cellSize || 
                        bullet.position.z < 0 || bullet.position.z > gridSize * cellSize) {
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                    }
                }
            }
        }

        // Debug overlay
        const debugElement = document.getElementById('debug');
        function updateDebug() {
            if (soldier) {
                const pos = soldier.position;
                const rot = THREE.MathUtils.radToDeg(soldier.rotation.y);
                debugElement.innerHTML = `
                    Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})<br>
                    Rotation: ${rot.toFixed(1)}Â°<br>
                    Enemies: ${enemies.length}
                `;
            }
        }

        // Responsive design
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (mixer) mixer.update(delta);
            moveSoldier(delta);
            moveEnemies(delta);
            updateBullets(delta);
            updateDebug();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>